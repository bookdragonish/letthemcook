import type { MealsArgs, Meal } from "../types/Meals";
import { Collection, Filter } from "mongodb";
import { cacheWrap } from "../cache/cacheWrap";
import { cacheKeys } from "../cache/cacheKeys";
import { TTL } from "../cache/ttl";
import type { Redis } from "ioredis";
import { CommentSection } from "../types/Comments";

// Root resolvers that define the functions available.
// Corresponds to a Query or Mutation
export const resolvers = (
  mealsCollection: Collection<Meal>,
  commentsCollection: Collection<CommentSection>,
  redis: Redis | null
) => ({
  // ---------------------------------------------------------------
  //                          Meal Related
  // ---------------------------------------------------------------
  //All meals
  meals: async ({
    order = 1,
    category,
    page = 1,
    limit = 20,
  }: MealsArgs = {}) => {
    // Filter by category
    const filter: Filter<Meal> = {};
    if (category && category != "All") {
      filter.strCategory = category;
    }

    // Key determine the sorting in the cache, deciding how to get each object
    const key = cacheKeys.meals(order, category || "All", page, limit);
    if (redis) {
      // Try finding cached response using key.
      return cacheWrap(redis, key, TTL.MEALS, async () => {
        const skip = (page - 1) * limit;
        const total = await mealsCollection.countDocuments(filter);
        const data = await mealsCollection
          .find(filter)
          .sort({ strMeal: order})
          .skip(skip)
          .limit(limit)
          .toArray();

        // Returns same object as the missing redis function
        return {
          data,
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        };
      });
    }

    // Fallback using no redis:
    //Amount of result that are to be skipped and total object count
    const skip = (page - 1) * limit;
    const total = await mealsCollection.countDocuments(filter);

    // Find all meals and sort them
    const data = await mealsCollection
      .find(filter)
      .sort({ strMeal: order }) // sort alphabetically (ascending), -1 is descending
      .skip(skip) // Amount of objects from beginning that are to be skipped
      .limit(limit) // Stops at the limit (we get n=limit amount of objects)
      .toArray();

    return {
      data,
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    };
  },

  // Get meal by using id
  meal: async ({ id }: { id: string }) => {

    const categoryArray = ["All", "Vegetarian", "Vegan", "Beef", "Chicken", "Seafood", "Dessert"];

    if (categoryArray.includes(id)) {
      const category = id;
      const filter: Filter<Meal> = {};
      if (category !== "All") {
        filter.strCategory = category;
      }

      const total = await mealsCollection.countDocuments(filter);
      if (total === 0) return null;

      /**
      * AI GEN:
      * Logic for finding random index using Math was generated by AI (ChatGPT)
      */
      const randomIndex = Math.floor(Math.random() * total);

      const [meal] = await mealsCollection
        .find(filter)
        .skip(randomIndex)
        .limit(1)
        .toArray();

      return meal;
  
    }
    // Using redis to cache single recipes
    const key = cacheKeys.meal(id);
    if (redis) {
      return cacheWrap(redis, key, TTL.MEAL, async () => {
        return mealsCollection.findOne({ idMeal: id });
      });
    }
    // Fallback if no redis
    const meal = await mealsCollection.findOne({ idMeal: id });
    return meal;
  },

  // Get meal by search query
  searchMeals: async ({
    value,
    page = 1,
    limit = 20,
  }: {
    value: string;
    page: number;
    limit: number;
  }) => {
    const regex = new RegExp(value, "i");
    // Query to reuse for count + find
    const query = {
      $or: [{ strMeal: regex }, { strCategory: regex }],
    };

    //Amount of result that are to be skipped and total object count
    const skip = (page - 1) * limit;
    const total = await mealsCollection.countDocuments(query);

    const data = await mealsCollection
      .find({
        $or: [{ strMeal: regex }, { strCategory: regex }],
      })
      .skip(skip) // Amount of objects from beginning that are to be skipped
      .limit(limit) // Stops at the limit (we get n=limit amount of objects)
      .toArray();

    return {
      data,
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    };
  },

  // ---------------------------------------------------------------
  //                          Comment Related
  // ---------------------------------------------------------------

  // Getting all comments related to the recipe
  commentsByRecipe: async ({ recipeID }: { recipeID: string }) => {

    const section = await commentsCollection.findOne({ recipeID });

    // Create a new one if there is no comment section for this recipe
    if (!section) {
      return { recipeID, comments: [] };
    }

    //Sorting the comments
    if (section.comments.length > 0) {
      section.comments.sort(
        (a: { date: string }, b: { date: string }) =>
          new Date(b.date).getTime() - new Date(a.date).getTime()
      );
    }

    return { recipeID, comments: section.comments };
  },

  // Adding comments functions
  addComment: async ({
    recipeID,
    anonymousName,
    comment,
  }: {
    recipeID: string;
    anonymousName: string;
    comment: string;
  }) => {
    const newComment = {
      anonymousName,
      comment,
      date: new Date().toISOString(),
    };

    if (anonymousName == "" || comment == "") return null; // Don't add empty comments or comments with empty names

    // Push the new comment into the recipe's comment array
    await commentsCollection.updateOne(
      { recipeID },
      { $push: { comments: newComment } },
      { upsert: true } // create if doesn't exist
    );

    const updatedSection = await commentsCollection.findOne({ recipeID });
    return updatedSection;
  },
});
